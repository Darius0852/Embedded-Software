# Introduction to RTOS
(Real time operating system)

## Implications of an RTOS approach

- Practical implications of using RTOS
	- Mapping of multiple processes onto a single CPU
		- Future application to multi- processor hardware
	- Synchronization between tasks
		- Implies cooperation
	- Sharing of resources

- Providing these facilities is the responsibility of a real time operating system (RTOS) 

## Today look at Basic Terminology

- Sharing a CPU
- Virtual Machine
- System Machine
- Process Descriptores
- Scheduling

## Sharing the CPU - 1
Eg on personal computer you are using now (Mac) uses multithreading to do everything you do, read documents, notifications, time keeping, different windows. However, it runs on Mac OS not a RTOS but still doing multi-tasking. 

- Multi-tasking (pseudo concurrency) - meaning they appear to be running at the same time but they are in fact sequenced (when sharing the one CPU) computers with more than 1 CPU can do tasks in actual concurrency.
	- The interleaving of a number of tasks, at HIGH SPEED, provides a good approximation to TRUE CONCURRENCY
	- Modern Processors are very powerful
		- Allowing more and faster switching
	- Sum total of computation time cannot exceed available compute time
	- System time = waste time

## Sharing the CPU - 2
- Most I/O devices are slower than the electronic speeds of the processor.
	- E.g. comms channels, disks, sensors.
	- Mechanical compared to electronic speeds.
- The time between initiating an I/O action and its completion can be large in comparison to the speed of execution of a processor instruction.
- This “dead time” could be used to execute useful code.
- Implementation will increase complexity of the support software.
- DMA hardware can be used to create this effect with electronic speed I/O hardware.

## Virtual Machine - 1
In the example in Sharing CPU - 3 the tasks are independent (there is no reliance on data sharing between tasks), they are only connected through the RTOS which starts and stops the tasks.

- Each task in a systems should execute without DIRECT knowledge of the other tasks.
- Indirect knowledge exists by tasks sharing common resources
- Each task can then be considered to execute in its own VIRTUAL MACHINE (VM) whose characteristics are simpler and cleaner than the underlying PHYSICAL MACHINE
	- E.g. the Vm provide disk file services which are defined at a level well above the disk hardware.
- It is the purpose of the RTOS to map a sets of VM’s onto the physical hardware.

“Virtual Machine” term not used in the normal way we talk about computers we are just saying that they each run their own tasks, the tasks are all linked to the RTOS which acts like a library but the tasks remain independent of each other.

RTOS can be viewed as an extension to the basic processor hardware
	- Possible implementation as extra hardware on the chip

## System Protection - 1

### Software only protection

- Hardware can only be accessed by calling RTOS routines
	- Written by “experts”
	- Efficient and tested
- RTOS can check the parameters to these system calls
	- E.g. The call to an analogue input routine would check that the specified channel is real.
	- E.g. The call to a disk I/O block read routine would check that the specified block did exist.
- Easily bypassed by the programmer
	- Not safe or secure.
- Common approach for the majority of small to medium sized systems.

## System Protection - 2

### Hardware protection
- No hardware = unprotected system
	- Responsibility of the programmer to develop safe software.
	- Faults can lead to difficult to debug code
		- Stack overflows, buffer overflows
- Controller memory access
	- Imposition of limits to which part of memory a task can access
	- Access outwit these limits causes a jump to an error handling routine
		- E.g. segmentation error
	- Types of access
		- R/O : Read Only
		- R/W : Read Write
		- EX : Execute

## System Protection - 2

### Stack overflow protection

- Stack is heavily used in code generated by high-level language compilers
- Example from MBED
	- RTOS memory Map
There is dynamically allocated units of data in the Heap (inside of stack) called “Malloc” when called

This is used for example for LOCAL VARIABLES use inside fucnction calls.

The MAIN STACK and the HEAP are build from opposite ends of the stack. This is so that they do not meet (least chance possible)

So one starts from the top and moves down saving variables and data like global variables from the main thread whilst the short term local variables are stored in the heap going from the bottom of the stack and moving upwards.

Otherwise if they meet then the heap may overwrite variables form the stack and your program will be completely corrupted

When they meet it because your out of memory (overlapping)

## System Protection - 3

So how do we check if they are overlapping (seems easy but isn’t)

### Stack overflow protection

- Stack is heavy used in code generated by high-level language compilers
- Example from MBED
	- RTOS memory MAP


It is hard to know the state of the memory during execution and if they will overlap.

## System Protection - 4

### Stack overflow protection

#### Detection used in FreeRTOS

1. Check stack pointer at each switch from task to task
		- Very fast
		- Not guaranteed to detect all stack software
2. On start-up load stack area with a known set of values and regularly check that the last few words of the stack have not been overwritten.
		- Quite fast
		- Will catch all overflow conditions

Neither provides ‘real-time’ checks
	- Would be too inefficient 

## System Protection - 5

When you have SYSTEM PROTECTION (HARDWARE PROTECTION) it means you have a SUBSET of the computer INSTRUCTION which ar actually PROTECTED.
Therefore you cannot execute these instructions directly, only in KERNEL MODE. Only the operating system operates in KERNEL MODE. Eg linux. Linux has a kernel space and hardware protection so it only runs on hardware that is provided with those protection facilities.

So the kernel can execute all the instructions.

Use of KERNEL?USER spaces
- Defines the ability to execute a SUBSET of the computer instruction set
- KERNEL
	- Can execute ALL instructions
- USER (also called SYSTEM or SUPERVISOR)
	- ALL instructions except e.g. HALT, RESET, I/O, STATUS WORD CONTROL, etc

An interrupt (software interrupt) is required to transfer from USER to KERNEL space. Cannot be done with subroutine.

## Interrupt Structure

#### Family of Interrupts

![](https://github.com/Darius0852/Embedded-Software/blob/main/images/RTOS1.png)

- A TRAP is used in place of a “jump to subroutine”
	- Jump to subroutine using the interrupt system.
	- Synchronous interrupt.

- KERNEL and USER spaces often have differing sets of registers
	- Minimum would be separate stack pointers


## Task Attributes

#### A TASK or PROCESS can be considered to have the following attributes:
	- Block of executable Code
	- Data area
	- Process descriptor
	- “thread of execution”

#### Executable code
	- Single unit of sequential code
	- Suitable for RAM or ROM


The pointer to the function is needed so that it knows where the executable code is when the task is to be executed. This is any code loaded from memory.

## Task : data area
### Data area is split into three types

1. Global
	- Memory resident, statically allocated.

2. Local
	- Memory resident, dynamically allocated
	- Stack based
	- Created on entry to a subroutine
		- Frame based
	- Provides efficient use of available memory

3. CPU resident
	- Internal registers of the processor
	- Different for each processor
	- Called the CONTEXT or VOLATILE ENVIRONEMNT
	- E.g. Microchip 16 series
		- W-register, status register, program counter
	- Needs to be managed when interrupts are used

## Function Frame
### A function frame pointer has the following structure

![](https://github.com/Darius0852/Embedded-Software/blob/main/images/RTOS2.png)

- Access to the “locals” and “arguments” is by adding a constant to the “frame pointer”.
	- E.g. use (frame_pointer + (-2) to access “local2”

### One frame is created for each call to a function
	- Frame is destroyed on return from the function

## Task : Context 
### Saving and restoring the CONTEXT is wasted time
- Problems can arise if 
	- More task switching is performed
	- The processor has more internal registers e.g. floating point coprocessor.

### Possible solutions
- Adopt architectures with less CPU registers
	- E.g. Transputer (circa 1990)
		- 3 internal CPU registers
		- 600ns context switch time (FAST)

- Have multiple sets of CPY registers
	- 2 or more

- Keep registers in main memory and access by a pointer
	- E.g. Texas 990
	- 16 register block in memory (called workspace)
	- CONTEXT = status, PC, workspace pointer register


## Task / Process descriptor
### Area set aside to hold ALL relevant information about a task
- Also called CONTROL BLOCK or STATE VECTOR

### Contains 
- Identification
	- Implicit
		- Based opposition in a table of queue (most common approach)
	- Explciti
		-  a name or a number
	- Task status
		- One of EXECUTING or READY_TO_EXECUTE or WAITING_FOR_AN_EVENT
		- Referred to as EXECUTING, READY, and WAITING
	- Storage for the context
	- Priority
	- Other

## Task State

### System viewed as a state transition diagram

![](https://github.com/Darius0852/Embedded-Software/blob/main/images/RTOS3.png)

### (1) State changes due to events and task actions
### (2) State change due to RTOS unit called the SCHEDULER 

## State transition dynamics
### Priority
- Control task = HIGH
- Keyboard task = MEDIUM
- Logging task = LOW

- Higher priority tasks should always win over lower priority tasks.

## State Transition Implementation
### Software Implementation
- Usually based on queues
	- Single linked or double linked lists
	- Position in queue relates to the task priority
		- Saves expensive queue scanning.

- Involves the manipulation of pointers to process descriptors rather than the copying of the process descriptor
	- Much more efficient

![](https://github.com/Darius0852/Embedded-Software/blob/main/images/RTOS4.png)

## Task : thread of execution
### Refers to “shared code”
- One unit of code that can be used by multiple tasks
- Based on “re-entrant” code
	- Code that does not modify itself
	- Essential to prevent corruption due to multiple accesses
	- Most compilers produce re-entrant code
- Similar to Windows DLLs
























